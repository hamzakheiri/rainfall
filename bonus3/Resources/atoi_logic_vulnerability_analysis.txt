atoi() Logic Vulnerability - Bonus3
====================================

Vulnerability Type: Logic Flaw
Technique: atoi() edge case + strcmp() manipulation

The Vulnerability:
------------------
This challenge demonstrates a logic vulnerability where:
1. atoi() converts empty string to 0
2. Setting buffer[0] = '\0' makes buffer empty
3. strcmp("", "") returns 0 (equal)
4. Shell is executed

Program Flow:
-------------
1. Opens /home/user/end/.pass file
2. Reads 66 bytes from file into buffer
3. Sets buffer[89] = '\0'
4. Converts argv[1] to integer: index = atoi(argv[1])
5. Sets buffer[index] = '\0'
6. Reads another 65 bytes from file
7. Compares buffer with argv[1] using strcmp()
8. If equal, executes /bin/sh

The atoi() Function:
--------------------
atoi() converts a string to an integer:

int atoi(const char *str);

Behavior:
- Skips leading whitespace
- Reads optional sign (+ or -)
- Reads digits until non-digit
- Returns integer value
- Returns 0 if no valid conversion

Edge Cases:
atoi("")           → 0
atoi("0")          → 0
atoi("abc")        → 0
atoi("  123")      → 123
atoi("-456")       → -456
atoi("123abc")     → 123
atoi("2147483648") → undefined (overflow)

The Exploit:
------------
Input: ./bonus3 ""

Step-by-step:
1. argv[1] = ""
2. index = atoi("") = 0
3. buffer[0] = '\0'
4. buffer is now "" (empty string)
5. strcmp(buffer, argv[1]) = strcmp("", "") = 0
6. Condition is true!
7. execl("/bin/sh", "sh", NULL) executes

Memory Layout:
--------------
Before buffer[0] = '\0':
┌─────────────────────────────────────────────────────┐
│ buffer[0-65]: password from file                    │
├─────────────────────────────────────────────────────┤
│ buffer[66-130]: second read from file               │
├─────────────────────────────────────────────────────┤
│ buffer[131]: null terminator                        │
└─────────────────────────────────────────────────────┘

After buffer[0] = '\0':
┌─────────────────────────────────────────────────────┐
│ buffer[0]: '\0' ← String ends here!                 │
├─────────────────────────────────────────────────────┤
│ buffer[1-65]: (ignored by strcmp)                   │
├─────────────────────────────────────────────────────┤
│ buffer[66-130]: (ignored by strcmp)                 │
├─────────────────────────────────────────────────────┤
│ buffer[131]: (ignored by strcmp)                    │
└─────────────────────────────────────────────────────┘

strcmp() only reads until first null byte!

The strcmp() Function:
----------------------
strcmp() compares two strings:

int strcmp(const char *s1, const char *s2);

Returns:
- 0 if strings are equal
- < 0 if s1 < s2
- > 0 if s1 > s2

Behavior:
- Compares byte by byte
- Stops at first null terminator
- Returns difference of first non-matching bytes

Examples:
strcmp("", "")      → 0
strcmp("a", "a")    → 0
strcmp("a", "b")    → -1
strcmp("b", "a")    → 1
strcmp("abc", "ab") → 'c' (positive)
strcmp("", "a")     → -'a' (negative)

Why Empty String Works:
------------------------
When buffer[0] = '\0':
- strlen(buffer) = 0
- buffer is effectively ""
- strcmp("", "") = 0
- Condition is satisfied!

Alternative Approaches (Don't Work):
-------------------------------------
1. Using "0":
   ./bonus3 "0"
   - atoi("0") = 0
   - buffer[0] = '\0'
   - strcmp("", "0") != 0 ✗
   - Doesn't work!

2. Using non-numeric string:
   ./bonus3 "abc"
   - atoi("abc") = 0
   - buffer[0] = '\0'
   - strcmp("", "abc") != 0 ✗
   - Doesn't work!

3. Using whitespace:
   ./bonus3 " "
   - atoi(" ") = 0
   - buffer[0] = '\0'
   - strcmp("", " ") != 0 ✗
   - Doesn't work!

Only empty string works because:
strcmp("", "") == 0 ✓

Security Implications:
----------------------
1. atoi() returns 0 for invalid input
   - No error indication
   - Silent failure
   - Can lead to unexpected behavior

2. Unchecked array indexing
   - buffer[index] with no bounds check
   - Can write to arbitrary memory
   - Buffer overflow/underflow

3. Logic flaw in authentication
   - Comparing user input with buffer
   - Executing shell based on comparison
   - No proper authentication mechanism

4. File reading without validation
   - Reads from fixed file path
   - No permission checks
   - Assumes file exists

Potential Exploits:
-------------------
1. Empty string (current exploit):
   ./bonus3 ""
   → Shell access

2. Negative index (buffer underflow):
   ./bonus3 "-10"
   → Writes null byte before buffer
   → Potential memory corruption

3. Large index (buffer overflow):
   ./bonus3 "1000"
   → Writes null byte after buffer
   → Potential memory corruption

Prevention:
-----------
1. Validate input:
   if (strlen(argv[1]) == 0) {
       return -1;
   }

2. Check atoi() result:
   index = atoi(argv[1]);
   if (index < 0 || index >= sizeof(buffer)) {
       return -1;
   }

3. Use safer functions:
   // Instead of atoi()
   char *endptr;
   long val = strtol(argv[1], &endptr, 10);
   if (*endptr != '\0' || val < 0 || val >= sizeof(buffer)) {
       return -1;
   }

4. Don't execute based on user input:
   // Never do this:
   if (strcmp(buffer, argv[1]) == 0) {
       execl("/bin/sh", "sh", NULL);
   }

5. Use proper authentication:
   // Use cryptographic hash comparison
   // Use time-constant comparison
   // Use proper privilege separation

Example Safe Code:
------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <limits.h>

int main(int argc, char **argv) {
    FILE *file;
    char buffer[132];
    char *endptr;
    long index;
    
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <index>\n", argv[0]);
        return 1;
    }
    
    // Validate input is not empty
    if (strlen(argv[1]) == 0) {
        fprintf(stderr, "Error: Empty input\n");
        return 1;
    }
    
    // Use strtol() instead of atoi()
    errno = 0;
    index = strtol(argv[1], &endptr, 10);
    
    // Check for conversion errors
    if (errno != 0 || *endptr != '\0') {
        fprintf(stderr, "Error: Invalid number\n");
        return 1;
    }
    
    // Bounds checking
    if (index < 0 || index >= sizeof(buffer)) {
        fprintf(stderr, "Error: Index out of bounds\n");
        return 1;
    }
    
    file = fopen("/home/user/end/.pass", "r");
    if (file == NULL) {
        perror("fopen");
        return 1;
    }
    
    memset(buffer, 0, sizeof(buffer));
    fread(buffer, 1, 66, file);
    buffer[89] = '\0';
    
    // Safe array access
    buffer[index] = '\0';
    
    fread(buffer + 66, 1, 65, file);
    fclose(file);
    
    // Don't execute shell!
    // Just print the result
    printf("Buffer: %s\n", buffer);
    printf("Input: %s\n", argv[1]);
    
    return 0;
}

Key Lessons:
------------
1. atoi() is unsafe
   - Returns 0 for invalid input
   - No error indication
   - Use strtol() instead

2. Always validate input
   - Check for empty strings
   - Check for valid ranges
   - Use proper error handling

3. Bounds checking is critical
   - Check array indices
   - Prevent buffer overflow/underflow
   - Use size_t for sizes

4. Don't trust user input
   - Validate everything
   - Use whitelisting
   - Sanitize input

5. Logic flaws are subtle
   - Test edge cases
   - Consider all inputs
   - Think like an attacker

Flag:
-----
3321b6f81659f9a71c76616f606e4b50189cecfea611393d5d649f75e157353c

